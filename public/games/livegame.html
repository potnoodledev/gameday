<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Racer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto:wght@400&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Roboto', sans-serif; -webkit-tap-highlight-color: transparent; }
        .orbitron { font-family: 'Orbitron', sans-serif; }
        #gameCanvas { display: block; width: 100%; height: 100%; }
        .touch-button {
            touch-action: manipulation; /* Prevents double tap zoom etc. */
            user-select: none; /* Prevents text selection */
            -webkit-user-select: none;
        }
    </style>
</head>
<body class="bg-gray-800 text-white overflow-hidden">

    <div id="gameContainer" class="absolute inset-0 z-0">
        <!-- Canvas will be appended here by Three.js -->
    </div>

    <header class="absolute top-0 left-0 right-0 p-3 z-10 bg-black/40 backdrop-blur-sm">
        <h1 class="text-xl md:text-2xl orbitron text-center text-cyan-400 tracking-wider">Vector Racer 3D</h1>
    </header>

    <div id="uiContainer" class="absolute bottom-0 left-0 right-0 p-2 pb-3 md:p-4 z-10 bg-black/40 backdrop-blur-sm flex flex-col items-center">
        <div id="speedDisplay" class="text-lg md:text-xl orbitron mb-2 text-yellow-400">Speed: 0 KM/H</div>
        <div id="instructions" class="text-xs md:text-sm text-center text-gray-300 mb-2 px-2">
            Controls: [W/↑] Accel, [S/↓] Brake/Reverse, [A/←] Left, [D/→] Right
        </div>
        <!-- Touch Controls for Mobile -->
        <div id="touchControlsContainer" class="w-full md:hidden">
            <div id="touchControls" class="grid grid-cols-3 gap-2 w-full max-w-sm mx-auto px-2">
                <div></div> <!-- Spacer -->
                <button id="gasButton" class="touch-button bg-green-500/80 hover:bg-green-600/80 text-white font-bold py-3 rounded active:bg-green-700/80 text-2xl">▲</button>
                <div></div> <!-- Spacer -->
                <button id="leftButton" class="touch-button bg-blue-500/80 hover:bg-blue-600/80 text-white font-bold py-3 rounded active:bg-blue-700/80 text-2xl">◄</button>
                <button id="brakeButton" class="touch-button bg-red-500/80 hover:bg-red-600/80 text-white font-bold py-3 rounded active:bg-red-700/80 text-2xl">▼</button>
                <button id="rightButton" class="touch-button bg-blue-500/80 hover:bg-blue-600/80 text-white font-bold py-3 rounded active:bg-blue-700/80 text-2xl">►</button>
            </div>
        </div>
    </div>

    <div id="loadingScreen" class="absolute inset-0 bg-gray-900 flex flex-col items-center justify-center z-50">
        <div class="text-3xl orbitron text-cyan-400 animate-pulse">LOADING</div>
        <div class="text-gray-400 mt-2">Please wait...</div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        let scene, camera, renderer, clock;
        let playerCar, carSpeed = 0;
        const keysPressed = {};

        const gameContainer = document.getElementById('gameContainer');
        const speedDisplay = document.getElementById('speedDisplay');
        const loadingScreen = document.getElementById('loadingScreen');
        
        // Car physics parameters (tuned for deltaTime)
        const CAR_PROPS = {
            maxSpeed: 35, // units per second
            acceleration: 20, // units per second^2
            brakingForce: 50, // units per second^2
            reverseMaxSpeed: -10,
            reverseAcceleration: 10,
            friction: 2.5, // Frictional deceleration factor (force = speed * friction)
            steeringAngularVelocity: Math.PI * 0.6, // Radians per second for car body rotation
            bodyDimensions: { width: 1.7, height: 0.8, length: 3.8 },
            wheelRadius: 0.4,
            wheelWidth: 0.3,
        };

        const TRACK_PROPS = {
            width: 20,
            length: 400, // A long straight track
            wallHeight: 2,
            wallThickness: 1,
        };
        const cameraOffset = new THREE.Vector3(0, 5, -9); // Behind and above car
        let wheels = [];


        function init() {
            clock = new THREE.Clock();

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x60A5FA); // Sky blue
            scene.fog = new THREE.Fog(0x60A5FA, 50, 200);

            // Camera
            camera = new THREE.PerspectiveCamera(75, gameContainer.clientWidth / gameContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 10, -15); // Initial camera position

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            gameContainer.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(20, 30, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            const shadowCamSize = 40;
            directionalLight.shadow.camera.left = -shadowCamSize;
            directionalLight.shadow.camera.right = shadowCamSize;
            directionalLight.shadow.camera.top = shadowCamSize;
            directionalLight.shadow.camera.bottom = -shadowCamSize;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 100;
            scene.add(directionalLight);


            createTrack();
            createCar();
            setupControls();

            window.addEventListener('resize', onWindowResize);
            
            loadingScreen.style.display = 'none';
            document.body.classList.add('game-active');
            animate();
        }

        function createCar() {
            playerCar = new THREE.Group();
            playerCar.position.set(0, CAR_PROPS.wheelRadius, -TRACK_PROPS.length / 2 + 20); // Start near one end
            playerCar.rotation.y = 0; // Facing positive Z

            // Car Body
            const bodyGeo = new THREE.BoxGeometry(CAR_PROPS.bodyDimensions.width, CAR_PROPS.bodyDimensions.height, CAR_PROPS.bodyDimensions.length);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff3333, flatShading: false });
            const carBody = new THREE.Mesh(bodyGeo, bodyMat);
            carBody.position.y = CAR_PROPS.bodyDimensions.height / 2; // Body is on top of wheels
            carBody.castShadow = true;
            carBody.receiveShadow = true;
            playerCar.add(carBody);
            
            // Car Windshield (simple)
            const windshieldGeo = new THREE.BoxGeometry(CAR_PROPS.bodyDimensions.width * 0.9, CAR_PROPS.bodyDimensions.height * 0.6, CAR_PROPS.bodyDimensions.length * 0.02);
            const windshieldMat = new THREE.MeshPhongMaterial({ color: 0x60A5FA, transparent: true, opacity: 0.5 });
            const windshield = new THREE.Mesh(windshieldGeo, windshieldMat);
            windshield.position.set(0, CAR_PROPS.bodyDimensions.height / 2 + CAR_PROPS.bodyDimensions.height*0.1, CAR_PROPS.bodyDimensions.length/2 * 0.4);
            windshield.rotation.x = -Math.PI / 12;
            playerCar.add(windshield);


            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(CAR_PROPS.wheelRadius, CAR_PROPS.wheelRadius, CAR_PROPS.wheelWidth, 24);
            const wheelMat = new THREE.MeshPhongMaterial({ color: 0x222222, flatShading: false });
            
            const wheelPositions = [
                { x: -CAR_PROPS.bodyDimensions.width/2, y: 0, z: CAR_PROPS.bodyDimensions.length/2 * 0.7, front: true },  // Front Left
                { x:  CAR_PROPS.bodyDimensions.width/2, y: 0, z: CAR_PROPS.bodyDimensions.length/2 * 0.7, front: true },  // Front Right
                { x: -CAR_PROPS.bodyDimensions.width/2, y: 0, z: -CAR_PROPS.bodyDimensions.length/2 * 0.7, front: false }, // Rear Left
                { x:  CAR_PROPS.bodyDimensions.width/2, y: 0, z: -CAR_PROPS.bodyDimensions.length/2 * 0.7, front: false }  // Rear Right
            ];

            wheelPositions.forEach(posData => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2; // Align cylinder axis to be axle
                wheel.position.set(posData.x, posData.y, posData.z);
                wheel.castShadow = true;
                playerCar.add(wheel);
                wheels.push({mesh: wheel, isFront: posData.front});
            });
            scene.add(playerCar);
        }

        function createTrack() {
            // Ground
            const groundTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAABGUUKwAAAAUElEQVR4Ae3ZUQ0AIAADsM7/o20KExgcBPoDyOASESIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiItLXAdK8Aj3hPSfWAAAAAElFTkSuQmCC'); // Simple 64x64 grey texture
            groundTexture.wrapS = THREE.RepeatWrapping;
            groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(TRACK_PROPS.width / 4, TRACK_PROPS.length / 4); // Adjust repeat based on texture size and plane size
            
            const groundMaterial = new THREE.MeshPhongMaterial({ map: groundTexture, color: 0x666666 });
            const groundGeometry = new THREE.PlaneGeometry(TRACK_PROPS.width, TRACK_PROPS.length);
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Walls
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const wallLeftGeo = new THREE.BoxGeometry(TRACK_PROPS.wallThickness, TRACK_PROPS.wallHeight, TRACK_PROPS.length);
            const wallLeft = new THREE.Mesh(wallLeftGeo, wallMaterial);
            wallLeft.position.set(-(TRACK_PROPS.width / 2) - (TRACK_PROPS.wallThickness / 2), TRACK_PROPS.wallHeight / 2, 0);
            wallLeft.castShadow = true;
            wallLeft.receiveShadow = true;
            scene.add(wallLeft);

            const wallRight = new THREE.Mesh(wallLeftGeo, wallMaterial); // Reuse geometry
            wallRight.position.set((TRACK_PROPS.width / 2) + (TRACK_PROPS.wallThickness / 2), TRACK_PROPS.wallHeight / 2, 0);
            wallRight.castShadow = true;
            wallRight.receiveShadow = true;
            scene.add(wallRight);
        }

        function setupControls() {
            document.addEventListener('keydown', (event) => { keysPressed[event.key.toLowerCase()] = true; keysPressed[event.code] = true;});
            document.addEventListener('keyup', (event) => { keysPressed[event.key.toLowerCase()] = false; keysPressed[event.code] = false;});

            // Touch Controls
            const gasButton = document.getElementById('gasButton');
            const brakeButton = document.getElementById('brakeButton');
            const leftButton = document.getElementById('leftButton');
            const rightButton = document.getElementById('rightButton');

            const setupTouchButton = (button, key) => {
                button.addEventListener('pointerdown', (e) => { e.preventDefault(); keysPressed[key] = true; }, {passive: false});
                button.addEventListener('pointerup', (e) => { e.preventDefault(); keysPressed[key] = false; }, {passive: false});
                button.addEventListener('pointerleave', (e) => { if(e.pointerType !== "touch") keysPressed[key] = false; }); // Keep pressed if finger slides off then back on for touch
            };
            
            if (gasButton) setupTouchButton(gasButton, 'w');
            if (brakeButton) setupTouchButton(brakeButton, 's');
            if (leftButton) setupTouchButton(leftButton, 'a');
            if (rightButton) setupTouchButton(rightButton, 'd');
        }

        function updateCar(deltaTime) {
            let acl = 0;
            let turnDirection = 0;

            // Acceleration/Braking
            if (keysPressed['w'] || keysPressed['ArrowUp']) {
                acl = CAR_PROPS.acceleration;
            }
            if (keysPressed['s'] || keysPressed['ArrowDown']) {
                if (carSpeed > 0.1) acl = -CAR_PROPS.brakingForce; // Braking
                else acl = -CAR_PROPS.reverseAcceleration; // Reversing
            }

            carSpeed += acl * deltaTime;

            // Friction
            let frictionForce = Math.sign(carSpeed) * CAR_PROPS.friction * Math.abs(carSpeed) * deltaTime; // Simplified quadratic drag
            if (acl === 0) { // Stronger friction if no input
                 frictionForce *= 2;
            }
            if (Math.abs(carSpeed) > Math.abs(frictionForce)) {
                 carSpeed -= frictionForce;
            } else {
                 carSpeed = 0;
            }
            
            carSpeed = Math.max(CAR_PROPS.reverseMaxSpeed, Math.min(CAR_PROPS.maxSpeed, carSpeed));
             if (Math.abs(carSpeed) < 0.01 && acl === 0) carSpeed = 0;


            // Steering
            if (keysPressed['a'] || keysPressed['ArrowLeft']) turnDirection = 1;
            if (keysPressed['d'] || keysPressed['ArrowRight']) turnDirection = -1;

            if (Math.abs(carSpeed) > 0.1) { // Only allow steering if moving
                const steeringAmount = turnDirection * CAR_PROPS.steeringAngularVelocity * deltaTime;
                playerCar.rotateY(steeringAmount * (carSpeed >=0 ? 1 : -1)); // Invert steer when reversing
            }
            
            // Update car position
            const moveDirection = new THREE.Vector3(0, 0, 1); // Car's local forward
            moveDirection.applyQuaternion(playerCar.quaternion);
            const moveVector = moveDirection.multiplyScalar(carSpeed * deltaTime);
            playerCar.position.add(moveVector);

            // Collision with track boundaries
            const carHalfWidth = CAR_PROPS.bodyDimensions.width / 2 * Math.abs(Math.cos(playerCar.rotation.y)) + CAR_PROPS.bodyDimensions.length / 2 * Math.abs(Math.sin(playerCar.rotation.y));
            const carHalfLength = CAR_PROPS.bodyDimensions.length / 2 * Math.abs(Math.cos(playerCar.rotation.y)) + CAR_PROPS.bodyDimensions.width / 2 * Math.abs(Math.sin(playerCar.rotation.y));
            
            const trackEdgeX = TRACK_PROPS.width / 2 - carHalfWidth * 0.8; // 0.8 fudge factor for tighter feel
            const trackEdgeZ = TRACK_PROPS.length / 2 - carHalfLength;

            if (playerCar.position.x > trackEdgeX) {
                playerCar.position.x = trackEdgeX;
                carSpeed *= -0.3; // Bounce
            }
            if (playerCar.position.x < -trackEdgeX) {
                playerCar.position.x = -trackEdgeX;
                carSpeed *= -0.3; // Bounce
            }
            if (playerCar.position.z > trackEdgeZ) {
                playerCar.position.z = trackEdgeZ;
                carSpeed *= -0.3; // Bounce
            }
            if (playerCar.position.z < -trackEdgeZ) {
                playerCar.position.z = -trackEdgeZ;
                carSpeed *= -0.3; // Bounce
            }

            // Animate wheels
            const wheelRotationSpeed = carSpeed / CAR_PROPS.wheelRadius * deltaTime;
            wheels.forEach(wheelData => {
                wheelData.mesh.rotation.x -= wheelRotationSpeed; // Assuming cylinder axis along world X after initial rotation
                // Front wheel steering animation (visual only)
                if (wheelData.isFront) {
                    wheelData.mesh.rotation.y = turnDirection * Math.PI / 8 * Math.min(1, Math.abs(carSpeed)/5); // Steer angle based on input and speed
                }
            });
        }

        function updateCamera() {
            const carPosition = new THREE.Vector3();
            playerCar.getWorldPosition(carPosition);

            const targetCameraPosition = carPosition.clone().add(
                cameraOffset.clone().applyQuaternion(playerCar.quaternion)
            );
            camera.position.lerp(targetCameraPosition, 0.08); // Smooth transition
            camera.lookAt(carPosition.add(new THREE.Vector3(0,1,0))); // Look slightly above car center
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            updateCar(deltaTime);
            updateCamera();
            
            speedDisplay.textContent = `Speed: ${Math.abs(Math.round(carSpeed * 3.6))} KM/H`; // unit/s to km/h approx

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = gameContainer.clientWidth / gameContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
        }

        init();
    </script>
</body>
</html>
