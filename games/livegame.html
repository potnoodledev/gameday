<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Three.js Driving Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Montserrat', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
        }
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .touch-button {
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            touch-action: manipulation; /* Prevent double tap zoom etc. */
        }
    </style>
</head>
<body>
    <div id="game-container"></div>

    <div id="ui-overlay" class="fixed inset-0 pointer-events-none">
        <!-- Desktop Instructions -->
        <div id="info-text" class="fixed top-4 left-1/2 -translate-x-1/2 hidden md:block bg-black/50 text-white p-2 px-4 rounded shadow text-center text-sm z-10 pointer-events-auto">
            W/A/S/D or Arrow Keys to Drive
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls" class="md:hidden fixed inset-x-0 bottom-0 p-6 z-10 flex justify-between items-end pointer-events-auto">
            <!-- Steering (Left) -->
            <div class="flex flex-col space-y-3">
                <button id="turn-left-mobile" class="touch-button bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold p-4 rounded-full shadow-lg active:scale-95 transition-transform w-20 h-20 flex items-center justify-center text-3xl pointer-events-auto">&larr;</button>
            </div>
            <div class="flex flex-col space-y-3">
                 <button id="turn-right-mobile" class="touch-button bg-gray-700/80 hover:bg-gray-600/80 text-white font-bold p-4 rounded-full shadow-lg active:scale-95 transition-transform w-20 h-20 flex items-center justify-center text-3xl pointer-events-auto">&rarr;</button>
            </div>

            <!-- Throttle/Brake (Right) -->
            <div class="flex flex-col space-y-3 items-center">
                <button id="accelerate-mobile" class="touch-button bg-green-500/80 hover:bg-green-400/80 text-white font-bold p-4 rounded-full shadow-lg active:scale-95 transition-transform w-20 h-20 flex items-center justify-center text-3xl pointer-events-auto">&uarr;</button>
                <button id="brake-mobile" class="touch-button bg-red-500/80 hover:bg-red-400/80 text-white font-bold p-4 rounded-full shadow-lg active:scale-95 transition-transform w-20 h-20 flex items-center justify-center text-3xl pointer-events-auto">&darr;</button>
            </div>
        </div>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer, car;
        let ground;

        const keys = {
            ArrowUp: false, W: false,
            ArrowDown: false, S: false,
            ArrowLeft: false, A: false,
            ArrowRight: false, D: false
        };

        // Car physics parameters
        const carParams = {
            speed: 0,
            acceleration: 0.02,
            deceleration: 0.01, // Natural deceleration/friction
            braking: 0.03,
            maxSpeed: 0.5,
            maxReverseSpeed: -0.2,
            turnSpeed: 0.035,
            wheelBase: 2.5 // Not used in this simple model, but good for thought
        };

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);


            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, -10); // Initial camera position
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 30, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            // const shadowHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
            // scene.add(shadowHelper);


            // Ground
            const groundGeometry = new THREE.PlaneGeometry(500, 500);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, side: THREE.DoubleSide }); // DarkOliveGreen
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Car
            const carGeometry = new THREE.BoxGeometry(1.5, 1, 3); // width, height, length
            const carMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red
            car = new THREE.Mesh(carGeometry, carMaterial);
            car.position.y = 0.5; // Half of car height
            car.castShadow = true;
            scene.add(car);
            car.userData.speed = 0; // Custom property for current speed

            // Add some simple trees
            createRandomTrees(100, 200);

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            setupControls();

            animate();
        }

        function createRandomTrees(count, spread) {
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // ForestGreen

            for (let i = 0; i < count; i++) {
                const trunkHeight = Math.random() * 4 + 2; // 2 to 6
                const trunkRadius = Math.random() * 0.2 + 0.1; // 0.1 to 0.3
                const leavesRadius = Math.random() * 1 + 0.8; // 0.8 to 1.8

                const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.7, trunkRadius, trunkHeight, 8);
                const trunk = new THREE.Mesh(trunkGeo, trunkMaterial);
                trunk.castShadow = true;
                trunk.receiveShadow = true;

                const leavesGeo = new THREE.SphereGeometry(leavesRadius, 8, 6);
                const leaves = new THREE.Mesh(leavesGeo, leavesMaterial);
                leaves.castShadow = true;
                leaves.receiveShadow = true;

                const x = (Math.random() - 0.5) * spread;
                const z = (Math.random() - 0.5) * spread;

                // Avoid placing trees too close to the start or on the car
                if (Math.sqrt(x*x + z*z) < 15) continue;

                trunk.position.set(x, trunkHeight / 2, z);
                leaves.position.set(x, trunkHeight + leavesRadius * 0.7, z);
                
                scene.add(trunk);
                scene.add(leaves);
            }
        }


        function setupControls() {
            document.addEventListener('keydown', (event) => {
                if (keys.hasOwnProperty(event.key)) keys[event.key] = true;
                if (event.code in keys) keys[event.code] = true; // For W,A,S,D
            });
            document.addEventListener('keyup', (event) => {
                if (keys.hasOwnProperty(event.key)) keys[event.key] = false;
                if (event.code in keys) keys[event.code] = false;
            });

            // Mobile controls
            const controlsMap = {
                'accelerate-mobile': 'ArrowUp',
                'brake-mobile': 'ArrowDown',
                'turn-left-mobile': 'ArrowLeft',
                'turn-right-mobile': 'ArrowRight',
            };

            for (const [buttonId, keyName] of Object.entries(controlsMap)) {
                const button = document.getElementById(buttonId);
                if (button) {
                    button.addEventListener('touchstart', (e) => { e.preventDefault(); keys[keyName] = true; }, { passive: false });
                    button.addEventListener('touchend', (e) => { e.preventDefault(); keys[keyName] = false; }, { passive: false });
                    button.addEventListener('mousedown', () => keys[keyName] = true); // For testing with mouse
                    button.addEventListener('mouseup', () => keys[keyName] = false);
                }
            }
        }

        function updateCarMovement() {
            const { acceleration, deceleration, braking, maxSpeed, maxReverseSpeed, turnSpeed } = carParams;
            let currentSpeed = car.userData.speed;

            // Acceleration and Braking
            if (keys.ArrowUp || keys.W) {
                currentSpeed = Math.min(maxSpeed, currentSpeed + acceleration);
            } else if (keys.ArrowDown || keys.S) {
                currentSpeed = Math.max(maxReverseSpeed, currentSpeed - braking);
            } else {
                // Natural deceleration
                if (currentSpeed > 0) {
                    currentSpeed = Math.max(0, currentSpeed - deceleration);
                } else if (currentSpeed < 0) {
                    currentSpeed = Math.min(0, currentSpeed + deceleration);
                }
            }
            car.userData.speed = currentSpeed;

            // Steering (only when moving)
            if (Math.abs(currentSpeed) > 0.01) {
                let turnDirection = 0;
                if (keys.ArrowLeft || keys.A) turnDirection = 1;
                if (keys.ArrowRight || keys.D) turnDirection = -1;
                
                // Adjust turn speed based on current speed (less turn at high speed)
                const speedFactor = Math.max(0.2, 1 - Math.abs(currentSpeed) / maxSpeed); 
                car.rotation.y += turnDirection * turnSpeed * speedFactor * Math.sign(currentSpeed);
            }

            // Update car position
            // Move along the local Z axis (forward/backward)
            car.translateZ(currentSpeed);
        }
        
        function updateCamera() {
            if (!car) return;

            const cameraOffset = new THREE.Vector3(0, 4, -8); // Behind and above the car
            const relativeCameraOffset = cameraOffset.applyQuaternion(car.quaternion);
            const targetCameraPosition = car.position.clone().add(relativeCameraOffset);

            camera.position.lerp(targetCameraPosition, 0.1); // Smooth camera movement

            const lookAtPosition = car.position.clone().add(new THREE.Vector3(0,1,0)); // Look slightly above car center
            camera.lookAt(lookAtPosition);
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (car) {
                updateCarMovement();
                updateCamera();
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>